# this program includes the test of all the instructions, 
# in each function, we test the following instructions:
# ---main: j, jal, jalr, jr
# ---cal: addi, and, or, add, sub, andi, ori, xor, xori, nor
# ---shift: sll, srl, sra, lui, nop
# ---mem: sw, lw
# ---smaller: slt, slti
# ---branch: beq, bne, bgez, bgtz, blez, bltz

# all instructions:		
# ---addi, and, or, add, sub, andi, ori, xor, xori, nor,
# ---sll, srl, sra, lui, nop,
# ---beq, bne, bgez, bgtz, blez, bltz,
# ---slt, slti,
# ---sw, lw,
# ---j, jal, jalr, jr,

# (all the functions are void funct)

#		Assembly			Description				Address		Machine		Binary

# main: j, jal, jalr, jr
main:	addi $27, $0, 30	# $27 = 0x30			0			201b0030	001000 00000 11011 0000 0000 0011 0000
		jalr $27			# call $27(cal)			4			0360f809	000000 11011 00000 11111 00000 001001
		addi $1, $0, f..f	# $1 != f...f			8			2001ffff	001000 00000 00001 1111 1111 1111 1111
		jal  shift			# call shift			c			0c000019	000011 000000 0000 0000 0000 0001 1001
		addi $1, $0, f..f	# $1 != f...f			10			2001ffff	001000 00000 00001 1111 1111 1111 1111
		jal  mem			# call mem				14			0c00001f	000011 000000 0000 0000 0000 0001 1111
		addi $1, $0, f..f	# $1 != f...f			18			2001ffff	001000 00000 00001 1111 1111 1111 1111
		jal  smaller		# call smaller			1c			0c000022	000011 000000 0000 0000 0000 0010 0010
		addi $1, $0, f..f	# $1 != f...f			20			2001ffff	001000 00000 00001 1111 1111 1111 1111
		jal  branch			# call branch			24			0c000025	000011 000000 0000 0000 0000 0010 0101
		addi $1, $0, f..f	# $1 != f...f			28			2001ffff	001000 00000 00001 1111 1111 1111 1111
		j	 end			# jump end				2c			0800003e	000010 000000 0000 0000 0000 0011 1110

# cal: addi, and, or, add, sub, andi, ori, xor, xori, nor
cal:	addi $1, $0, 1		# $1 = 1				30			20010001	001000 00000 00001 0000 0000 0000 0001
		xori $2, $1, 7		# $2 = $1 ^ 7 = 6		34			38220007	001110 00001 00010 0000 0000 0000 0111
		ori  $3, $1, 2		# $3 = $1 | 2 = 3		38			34230002	001101 00001 00011 0000 0000 0000 0010
		add  $4, $0, $0		# $4 = $0 + $0 = 0		3c			00002020	000000 00000 00000 00100 00000 100000
		xor	 $5, $1, $2		# $5 = $1 | $2 = 7		40			00222826    000000 00001 00010 00101 00000 100110
		sub  $6, $5, $2		# $6 = $5 - $2 = 1		44			00a23022	000000 00101 00010 00110 00000 100010
		and	 $7, $3, $5		# $7 = $3 & $5 = 3		48			00653824	000000 00011 00101 00111 00000 100100
		andi $8, $2, fff9	# $8 = $2 & fff9 = 0	4c			3048fff9	001100 00010 01000 1111 1111 1111 1001
		or 	 $9, $6, $0		# $9 = $6 | $0 = 1		50			00c04825	000000 00110 00000 01001 00000 100101
		add  $10, $2, $7	# $10= $2 + $7 = 9		54			00475020	000000 00010 00111 01010 00000 100000
		andi $11, $5, 4		# $11= $5 & 4 = 4		58			30ab0004	001100 00101 01011 0000 0000 0000 0100
		nor	 $12, $10, $2	# $12= ~($10|$2)=f...f0 5c			01426027	000000 01010 00010 01100 00000 100111
		jr	 $31			# return				60			03e00008	000000 11111 0000000000 00000 001000

# shift: sll, srl, sra, lui, nop
shift:  lui	 $13, a			# $13= a<<16 = 000a0000	64			3c0d000a	001111 00000 01101 0000 0000 0000 1010
		sll	 $14, $13, 12	# $14= $13<<12 = a0...0	68			000d7300	000000 00000 01101 01110 01100 000000
		srl	 $15, $14, 29	# $15= $14>>28 = 0...0a	6c			000e7f02 	000000 00000 01110 01111 11100 000010
		sra	 $16, $14, 29	# $16= $14>>28 = f...fa	70			000e8703	000000 00000 01110 10000 11100 000011
		nop					# no operation			74			00000000
		jr	 $31			# return				78			03e00008	000000 11111 0000000000 00000 001000

# mem: sw, lw		
mem:	sw	 $15, 76($11)	# [80] = a				7c			ad6f004c	101011 01011 01111 0000 0000 0100 1100
		lw	 $17, 76($11)	# $17 = [80] = a		80			8d71004c	100011 01011 10001 0000 0000 0100 1100
		jr	 $31			# return				84			03e00008	000000 11111 0000000000 00000 001000
		
# smaller: slt, slti
smaller:slt  $18, $10, $15	# $18 = $10 < $15 = 1	88			014f902a	000000 01010 01111 10010 00000 101010
		slti $19, $10, 8	# $19 = $10 < 8 = 0		8c			29530008	001010 01010 10011 0000 0000 0000 1000
		jr	 $31			# return				90			03e00008	000000 11111 0000000000 00000 001000

# branch: beq, bne, bgez, bgtz, blez, bltz
# (skip means skipping the next instruction)
branch:	beq	 $6, $7, skip	# should not be taken	94			10c70001	000100 00110 00111 0000 0000 0000 0001
		addi $20, $0, a		# $20 = a				98			2014000a	001000 00000 10100 0000 0000 0000 1010
		beq	 $6, $9, skip	# should be taken		9c			10c90001	000100 00110 01001 0000 0000 0000 0001
		addi $20, $0, f..f	# $20 != f...f			a0			2014ffff	001000 00000 10100 1111 1111 1111 1111
		
		bne	 $6, $9, skip	# should not be taken	a4			14c90001	000101 00110 01001 0000 0000 0000 0001
		addi $21, $0, b		# $21 = b				a8			2015000b	001000 00000 10101 0000 0000 0000 1011
		bne	 $6, $7, skip	# should be taken		ac			14c70001	000101 00110 00111 0000 0000 0000 0001
		addi $21, $0, f..f	# $21 != f...f			b0			2015ffff	001000 00000 10101 1111 1111 1111 1111
		
		bgez $12, skip		# should not be taken	b4			05810001	000001 01100 00001 0000 0000 0000 0001
		addi $22, $0, c		# $22 = c				b8			2016000c	001000 00000 10110 0000 0000 0000 1100
		bgez $4, skip		# should be taken		bc			04810001	000001 00100 00001 0000 0000 0000 0001
		addi $22, $0, f...f	# $22 != f...f			c0			2016ffff	001000 00000 10110 1111 1111 1111 1111
		
		bgtz $12, skip		# should not be taken	c4			1d800001	000111 01100 00000 0000 0000 0000 0001
		addi $23, $0, d		# $23 = d				c8			2017000d	001000 00000 10111 0000 0000 0000 1101
		bgtz $6, skip		# should be taken		cc			1ca00001	000111 00101 00000 0000 0000 0000 0001
		addi $23, $0, f...f	# $23 != f...f			d0			2017ffff	001000 00000 10111 1111 1111 1111 1111	

		blez $6, skip		# should not be taken	d4			18a00001	000110 00101 00000 0000 0000 0000 0001
		addi $24, $0, e		# $24 = e				d8			2018000e	001000 00000 11000 0000 0000 0000 1110
		blez $12, skip		# should be taken		dc			19800001	000110 01100 00000 0000 0000 0000 0001
		addi $24, $0, f...f	# $24 != f...f			e0			2018ffff	001000 00000 11000 1111 1111 1111 1111
		
		bltz $4, skip		# should not be taken	e4			04800001	000001 00100 00000 0000 0000 0000 0001
		addi $25, $0, f		# $25 = f				e8			2019000f	001000 00000 11001 0000 0000 0000 1111
		bltz $12, skip		# should be taken		ec			05800001	000001 01100 00000 0000 0000 0000 0001
		addi $25, $0, f...f	# $25 != f...f			f0			2019ffff	001000 00000 11001 1111 1111 1111 1111		
		
		jr	 $31			# return				f4			03e00008	000000 11111 0000000000 00000 001000
	
# end:
end:	addi $26, $0, e..e	# $26 = f...f			f8			201affff	001000 00000 11010 1111 1111 1111 1111


